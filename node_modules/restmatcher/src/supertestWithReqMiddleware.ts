import express from 'express';
import supertest from "supertest";

const REQUEST_METHODS = ["checkout", "connect", "copy", "del", "delete", "get", "head", "lock", "merge", "mkactivity", "mkcol", "move", "notify", "options", "patch", "post", "propfind", "proppatch", "purge", "put", "report", "search", "subscribe", "trace", "unlock", "unsubscribe"];

/**
 * Works similar as the supertest function, but injects calls to middleware functions for each request
 * (or HTTP method respectively). Actually, this function is a proxy on top of supertest.
 * 
 * Example:
 * 
 * ```
 * const app = express();
 * app.get("/path", (req, res) => { res.send({value: req.headers.authorization}); });
 * 
 * // The middleware function:
 * function auth(req: Test) { return req.set('Authorization', `Bearer THIS_IS_NOT_A_REAL_TOKEN`); }
 * 
 * test("WithAuth", async() => {
 *     const testee = supertestWithReqMiddleware(app, auth);
 *     const response = await testee.get("/path");
 *     expect(response.body).toMatchObject({value: "Bearer THIS_IS_NOT_A_REAL_TOKEN"});
 * })
 * ```
 * If you need to add this often, just create a wrapper function:
 * ```
 * function supertestWithAuth(app: express.Express) {
 *      return supertestWithReqMiddleware(app, authenticator);
 * }
 *
 * const testee = supertestWithAuth(app);
 * const response = await testee.get("/path");
 * expect(response.body).toMatchObject({ value: "Bearer THIS_IS_NOT_A_REAL_TOKEN" });
 * ```
 * 
 * Note that the type `Test` here needs to be imported via
 * ```
 * import { Test } from 'supertest';
 * ```
 * 
 * @param app the express app to test
 * @param middlewareFcts functions that are called for each request (or HTTP method respectively) and can be used to add authentication headers.
 */
export function supertestWithReqMiddleware(app: express.Express, ...middlewareFcts: ((req: supertest.Test) => supertest.Test)[]) {
    return new Proxy<supertest.SuperTest<supertest.Test>>(supertest(app), {
        get: (target, prop, _receiver) => {
            const originalProperty = (target as any)[prop];
            if (typeof originalProperty === 'function' && typeof prop === "string" && REQUEST_METHODS.includes(prop)) {
                return function (...args: any[]) {

                    let result = (originalProperty as Function).apply(target, args) as supertest.Test;

                    if (result.constructor.name === "Test") { // we cannot use instanceof here due to bad typings
                        for (const middlewareFct of middlewareFcts) {
                            result = middlewareFct(result);
                        }
                    }
                    return result;
                }
            } else {
                return originalProperty;
            }
        }
    });
}
