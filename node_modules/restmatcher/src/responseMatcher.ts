
/**
 * Expected Status type, either a number or a string, or an array of those.
 * If it is a string, jokers ('*' or '?') are allowed.
 */
export type ExpectedStatusType = number | number[] | string | string[] | undefined;

/**
 * Used in toHaveValidationErrors matcher. 
 * Examples:
 * 
 * - `expect(res).toHaveValidationErrors()`:
 *   succeeds if at least one validation error is found
 * - `expect(res).toHaveValidationErrors(400)`:
 *   succeeds if at least one validation error is found and status code is 400
 * - `expect(res).toHaveValidationErrors(params: "ID")`:
 *   succeeds if the parameter "ID" caused a validation error
 * - `expect(res).not.toHaveValidationErrors()`:
 *   succeeds if no validations errors were omitted
 */
export type ResponseExpectation = {
    /**
     * Array of codes, status must be one of them, or a single number, or a string
     * to indicate a range. Use "x", "?", or "*" as joker, e.g. "4xx", "4??", or "4*"
     */
    status?: ExpectedStatusType,
    /**
     * A path in location body.
     */
    body?: string | string[]
    /**
     * A path in location query.
     */
    query?: string | string[]
    /**
     * A path in location params.
     */
    params?: string | string[]
    /**
     * A path in location cookies.
     */
    cookies?: string | string[]
    /**
     * A path in location headers
     */
    headers?: string | string[]
    /**
     * Any location, i.e. body, cookies, headers, params, or query, which caused the problem.
     */
    anyLocation?: string | string[]

}

const PATH_TO_VALIDATION_ERRORS_IN_BODY = ["errors"];
const SPECIFIC_LOCATIONS = ["body", "query", "params", "cookies", "headers"];
const ALL_LOCATIONS = [...SPECIFIC_LOCATIONS, "anyLocation"];


function toMsg(msgs: string | string[]) {

    // set here, otherwise it depends on the order of imports/require calls
    const MSG_PREFIX = process.env.CUSTOM_MATCHER_MSG_PREFIX ?? null;
    const MSG_POSTFIX = process.env.CUSTOM_MATCHER_MSG_POSTFIX ?? null;

    if (MSG_PREFIX != null && MSG_POSTFIX != null) {
        if (msgs instanceof Array) {
            if (msgs.length == 0) {
                return "";
            }
            return MSG_PREFIX + msgs.join(", ") + MSG_POSTFIX;
        }
        return MSG_PREFIX + msgs + MSG_POSTFIX;
    } else {
        if (msgs instanceof Array) {
            if (msgs.length == 0) {
                return "";
            }
            return msgs.join(", ");
        }
        return msgs;
    }
}

export const statusCode = (received: Response, expected: ExpectedStatusType) => {
    const errorParts: string[] = [] // they cause an exception to be thrown in any case (failure and success)
    const failureParts: string[] = [] // explanation of failure
    const statusCodeSuccessParts: string[] = [] // explanation of success

    checkStatus(received, expected, errorParts, failureParts, statusCodeSuccessParts);

    if (errorParts.length > 0) {
        throw new Error(errorParts.join(","));
    }
    if (failureParts.length === 0) {
        if (statusCodeSuccessParts.length !== 0) {
            return { pass: true, message: () => toMsg(statusCodeSuccessParts) };
        } else {
            return { pass: true, message: () => toMsg("No validations errors found.") };

        }
    } else {
        return { pass: false, message: () => toMsg(failureParts) };
    }
}

export const toHaveValidationErrorsExactly = (received: Response, expectedOrNothing?: ResponseExpectation) => {
    return checkValidationErrors(false, received, expectedOrNothing)
}
export const toHaveAtLeastValidationErrors = (received: Response, expectedOrNothing?: ResponseExpectation) => {
    return checkValidationErrors(true, received, expectedOrNothing)
}
export const toHaveNoValidationErrors = (received: Response, expected?: ExpectedStatusType) => {
    return checkValidationErrors(false, received, expected ? {
        status: expected
    } : undefined)
}
export const toHaveAnyValidationErrors = (received: Response, expected?: ExpectedStatusType) => {
    return checkValidationErrors(true, received, expected ? {
        status: expected
    } : undefined)
}


// The expected structure of the response, only for documentation purposes:
type ResponseWithErrors = {
    body: {
        errors: {
            location: "body" | "query" | "params" | "cookies" | "headers"
            param: string
        }[]
    }
}

/**
 * @param received 
 * @param expectedOrNothing 
 * @param atLeast
 *      If set to true AND if any location is defined, the test does not fail if 
 *      other validation errors except the given one were omitted. 
 *      That is, by default if a specific location.param (or path) is set, no other errors should occur.
 *      This setting is ignored, if no specific locations (or anyLocation) are defined. 
 * @returns 
 */
const checkValidationErrors = (atLeast: boolean, received: Response, expectedOrNothing?: ResponseExpectation) => {
    const expected: ResponseExpectation = expectedOrNothing ?? {};
    const errorParts: string[] = [] // they cause an exception to be thrown in any case (failure and success)
    const failureParts: string[] = [] // explanation of failure
    const successParts: string[] = [] // explanation of success
    const statusCodeSuccessParts: string[] = [] // explanation of success
    const noErrorsInBodyParts: string[] = []

    checkStatus(received, expectedOrNothing?.status ?? "*", errorParts, failureParts, statusCodeSuccessParts)

    const receivedErrorMap = getReceivedErrorMap()
    if (receivedErrorMap.size>0 || ! atLeast) {
        const foundErrorMap = new Map<string, string[]>();
        const specificErrorsWereExpected = checkExpectedErrors(receivedErrorMap, foundErrorMap)
        checkNotExpectedErrors(receivedErrorMap, foundErrorMap, specificErrorsWereExpected)
    }

    if (errorParts.length > 0) {
        throw new Error(errorParts.join(","));
    }
    if (failureParts.length === 0) {
        if (successParts.length !== 0) {
            return { pass: true, message: () => joinWithStatusSuccess(successParts) };
        } else if (noErrorsInBodyParts.length !== 0) {
            return { pass: !atLeast, message: () => joinWithStatusSuccess(noErrorsInBodyParts) };
        } else {
            return { pass: true, message: () => joinWithStatusSuccess(["No validations errors found."]) };

        }
    } else {
        return { pass: false, message: () => joinWithStatusSuccess(failureParts) }
    }


    function joinWithStatusSuccess(parts: string[]) {
        if (statusCodeSuccessParts.length > 0) {
            parts.push(...statusCodeSuccessParts);
        }
        return toMsg(parts.join('\n'));
    }


    // ---------------------------------------------------------------------------------------------
    // Internal helper

    function getPathsAtLocation(expectedLocation: string) {
        const paths = expected[expectedLocation as keyof ResponseExpectation] as (string | string[])
        if (!paths) {
            return [];
        }
        if (typeof paths === "string") {
            return [paths];
        }
        return paths
    }

    function checkExpectedErrors(receivedErrorMap: Map<string, string[]>, foundErrorMap: Map<string, string[]>) {
        let specificErrorsExpected = false;
        for (const expectedLocation of ALL_LOCATIONS) {
            const expectedPaths = getPathsAtLocation(expectedLocation)
            for (const expectedPath of expectedPaths) {
                specificErrorsExpected = true;
                if (expectedLocation === "anyLocation") {
                    let foundSpecific = false
                    for (const specificLocation of SPECIFIC_LOCATIONS) {
                        const receivedPaths = receivedErrorMap.get(specificLocation)
                        const index = receivedPaths ? receivedPaths.indexOf(expectedPath) : -1
                        if (index >= 0) {
                            getMapVal(foundErrorMap, specificLocation).push(expectedPath)
                            successParts.push(`${specificLocation}.${expectedPath} caused a validation error (matching any location).`)
                            foundSpecific = true;
                            break
                        }
                    }
                    if (!foundSpecific) {
                        failureParts.push(`${expectedPath} did not cause any validation errors at any location.`)
                    }
                } else {
                    const receivedPaths = receivedErrorMap.get(expectedLocation)
                    const index = receivedPaths ? receivedPaths.indexOf(expectedPath) : -1
                    if (index >= 0) {
                        getMapVal(foundErrorMap, expectedLocation).push(expectedPath)
                        successParts.push(`${expectedLocation}.${expectedPath} caused a validation error.`)
                    } else {
                        failureParts.push(`${expectedLocation}.${expectedPath} did not cause any validation errors.`)
                    }
                }
            }
        }
        return specificErrorsExpected;
    }

    function checkNotExpectedErrors(receivedErrorMap: Map<string, string[]>, foundErrorMap: Map<string, string[]>, specificErrorsExpected: boolean) {


        for (const specificLocation of SPECIFIC_LOCATIONS) {
            const receivedPaths = receivedErrorMap.get(specificLocation)
            const foundPaths = foundErrorMap.get(specificLocation)
            if (receivedPaths && foundPaths) {
                receivedErrorMap.set(specificLocation, receivedPaths.filter(receivedParam => foundPaths.indexOf(receivedParam) < 0));
            }
        }
        const unexpectedErrors: string[] = []
        for (const receivedEntry of receivedErrorMap.entries()) {
            if (receivedEntry[1].length > 0) {
                unexpectedErrors.push(...receivedEntry[1].map(param => `${receivedEntry[0]}.${param}`))
            }
        }
        if (unexpectedErrors.length > 0) {
            if (atLeast) {
                successParts.push(`Validation errors at ${unexpectedErrors.join(',')}.`)
            } else {
                failureParts.push(`Unexpected validation errors at ${unexpectedErrors.join(',')}.`)
            }
        }

    }

    function getReceivedErrorMap() {
        const map = new Map<string, string[]>();
        const body = received?.body as any;
        // ReadableStream is only defined in Node > 16!
        // if (received.body instanceof ReadableStream) {
        //     throw Error("This matcher is supposed to run in the context of SuperTest. Response body should have been parsed already.")
        // }
        if (!body) {
            noErrorsInBodyParts.push("No body set in response, cannot match validation errors.");
            return map;
        }
        if (typeof body !== "object") {
            noErrorsInBodyParts.push(`Body found, but it is not an object but ${typeof body}. Did you use restmatcher with supertest?`);
            return map;
        }
        let errors = body;
        for (const path of PATH_TO_VALIDATION_ERRORS_IN_BODY) {
            errors = errors[path];
            if (errors) {
                break;
            }
        }
        if (errors === undefined || errors === null) {
            noErrorsInBodyParts.push(`No validation errors found, property '${PATH_TO_VALIDATION_ERRORS_IN_BODY.join('.')}' not found in body.`)
            return map;
        }
        if (!(errors instanceof Array)) {
            noErrorsInBodyParts.push(`No validation errors found, '${PATH_TO_VALIDATION_ERRORS_IN_BODY.join('.')}' in body is not an array but a ${typeof errors}.`);
            return map;
        }
        for (const error of errors) {
            const location = error.location;
            const name = error.path || error.param; // version 7 vs. vs. 6 of express validator
            getMapVal(map, location).push(name)
        }
        return map;
    }
}

function checkStatus(received: Response, expectedStatusPattern: number | number[] | string | string[] | undefined,
    errorParts: string[], failureParts: string[], statusCodeSuccessParts: string[]) {
    const receivedStatus = String(received.status)
    if (receivedStatus.length != 3) {
        if (expectedStatusPattern !== undefined) {
            errorParts.push(`Status ${receivedStatus} is not a valid status code.`)
        } else {
            failureParts.push(`Status ${receivedStatus} is not a valid status code.`)
        }
        return;
    }
    if (!expectedStatusPattern || expectedStatusPattern === "*") { // no message if no status code expected or is any
        return;
    }

    const expectedStatusAsArray = normalizeExpectedStatusPattern(expectedStatusPattern);


    let statusOK = false
    statusArrayLoop: for (const expectedStatus of expectedStatusAsArray) {
        for (let c = 0; c < Math.min(receivedStatus.length, expectedStatus.length); c++) {
            const expectedChar = expectedStatus[c];
            if ('*' === expectedChar) {
                statusOK = true
                statusCodeSuccessParts.push(`Status code is ${receivedStatus} (matching ${expectedStatus}).`)
                break statusArrayLoop

            } else if (receivedStatus[c] === expectedChar || "xX?".includes(expectedChar)) {
                if (c === expectedStatus.length - 1) {
                    statusOK = true
                    statusCodeSuccessParts.push(`Status code is ${receivedStatus} (matching ${expectedStatus})`)
                    break statusArrayLoop
                }
            } else {
                break; // inner loop
            }

        }
    }
    if (!statusOK) {
        failureParts.push(`The received status ${receivedStatus} does not match expected status ${expectedStatusAsArray.join(',')}.`)
    }

}



function getMapVal(map: Map<string, string[]>, key: string) {
    let val = map.get(key);
    if (val === undefined) {
        val = [];
        map.set(key, val);
    }
    return val;
}

/**
 * Exported only for testing.
 */
export function normalizeExpectedStatusPattern(expectedStatusPattern: number | number[] | string | string[] | undefined): string[] {
    if (expectedStatusPattern === undefined) {
        return []
    }
    if (typeof expectedStatusPattern === "number") {
        return [String(expectedStatusPattern).padEnd(3, "x")]
    }
    if (typeof expectedStatusPattern === "string") {
        return [expectedStatusPattern]
    }
    return expectedStatusPattern.map(pattern => typeof pattern === "number" ? String(pattern).padEnd(3, "x") : pattern)
}
