/// <reference types="jest" />
import { ExpectedStatusType, ResponseExpectation } from "./responseMatcher";
export { ExpectedStatusType, ResponseExpectation } from "./responseMatcher";
export { parseCookies, Cookie } from "./parseCookies";
export { supertestWithReqMiddleware } from "./supertestWithReqMiddleware";
declare global {
    namespace jest {
        interface Matchers<R> {
            /**
             * Matches the status code.  If it is a string, jokers ('*' or '?') are allowed.
             */
            statusCode<Response>(expected?: ExpectedStatusType): CustomMatcherResult;
            /**
             * Matches if exactly the specified validation errors (and status code) occurred, i.e. no other validation
             * errors must occur. Only if no specific params are set, any error is just fine.
             */
            toHaveValidationErrorsExactly<Response>(expected?: ResponseExpectation): CustomMatcherResult;
            /**
             * Matches if at least the specified validation errors (and status code) occurred, i.e. other validation
             * errors may occur. If no validation errors are expected, the matcher will still fail if
             * no errors were found in the response at all.
             */
            toHaveAtLeastValidationErrors<Response>(expected?: ResponseExpectation): CustomMatcherResult;
            /**
             * Matches if no validation errors occurred.
             *
             * This is basically similar to `not.toHaveAtLeastValidationErrors()`.
             */
            toHaveNoValidationErrors<Response>(expected?: ExpectedStatusType): CustomMatcherResult;
            /**
             * Matches if any validation errors occurred.
             *
             * This is basically similar to `toHaveValidationErrorsExactly()`.
             */
            toHaveAnyValidationErrors<Response>(expected?: ExpectedStatusType): CustomMatcherResult;
        }
    }
}
//# sourceMappingURL=restmatcher.d.ts.map