"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.supertestWithReqMiddleware = void 0;
const supertest_1 = __importDefault(require("supertest"));
const REQUEST_METHODS = ["checkout", "connect", "copy", "del", "delete", "get", "head", "lock", "merge", "mkactivity", "mkcol", "move", "notify", "options", "patch", "post", "propfind", "proppatch", "purge", "put", "report", "search", "subscribe", "trace", "unlock", "unsubscribe"];
/**
 * Works similar as the supertest function, but injects calls to middleware functions for each request
 * (or HTTP method respectively). Actually, this function is a proxy on top of supertest.
 *
 * Example:
 *
 * ```
 * const app = express();
 * app.get("/path", (req, res) => { res.send({value: req.headers.authorization}); });
 *
 * // The middleware function:
 * function auth(req: Test) { return req.set('Authorization', `Bearer THIS_IS_NOT_A_REAL_TOKEN`); }
 *
 * test("WithAuth", async() => {
 *     const testee = supertestWithReqMiddleware(app, auth);
 *     const response = await testee.get("/path");
 *     expect(response.body).toMatchObject({value: "Bearer THIS_IS_NOT_A_REAL_TOKEN"});
 * })
 * ```
 * If you need to add this often, just create a wrapper function:
 * ```
 * function supertestWithAuth(app: express.Express) {
 *      return supertestWithReqMiddleware(app, authenticator);
 * }
 *
 * const testee = supertestWithAuth(app);
 * const response = await testee.get("/path");
 * expect(response.body).toMatchObject({ value: "Bearer THIS_IS_NOT_A_REAL_TOKEN" });
 * ```
 *
 * Note that the type `Test` here needs to be imported via
 * ```
 * import { Test } from 'supertest';
 * ```
 *
 * @param app the express app to test
 * @param middlewareFcts functions that are called for each request (or HTTP method respectively) and can be used to add authentication headers.
 */
function supertestWithReqMiddleware(app, ...middlewareFcts) {
    return new Proxy((0, supertest_1.default)(app), {
        get: (target, prop, _receiver) => {
            const originalProperty = target[prop];
            if (typeof originalProperty === 'function' && typeof prop === "string" && REQUEST_METHODS.includes(prop)) {
                return function (...args) {
                    let result = originalProperty.apply(target, args);
                    if (result.constructor.name === "Test") { // we cannot use instanceof here due to bad typings
                        for (const middlewareFct of middlewareFcts) {
                            result = middlewareFct(result);
                        }
                    }
                    return result;
                };
            }
            else {
                return originalProperty;
            }
        }
    });
}
exports.supertestWithReqMiddleware = supertestWithReqMiddleware;
//# sourceMappingURL=supertestWithReqMiddleware.js.map