"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalizeExpectedStatusPattern = exports.toHaveAnyValidationErrors = exports.toHaveNoValidationErrors = exports.toHaveAtLeastValidationErrors = exports.toHaveValidationErrorsExactly = exports.statusCode = void 0;
const PATH_TO_VALIDATION_ERRORS_IN_BODY = ["errors"];
const SPECIFIC_LOCATIONS = ["body", "query", "params", "cookies", "headers"];
const ALL_LOCATIONS = [...SPECIFIC_LOCATIONS, "anyLocation"];
function toMsg(msgs) {
    var _a, _b;
    // set here, otherwise it depends on the order of imports/require calls
    const MSG_PREFIX = (_a = process.env.CUSTOM_MATCHER_MSG_PREFIX) !== null && _a !== void 0 ? _a : null;
    const MSG_POSTFIX = (_b = process.env.CUSTOM_MATCHER_MSG_POSTFIX) !== null && _b !== void 0 ? _b : null;
    if (MSG_PREFIX != null && MSG_POSTFIX != null) {
        if (msgs instanceof Array) {
            if (msgs.length == 0) {
                return "";
            }
            return MSG_PREFIX + msgs.join(", ") + MSG_POSTFIX;
        }
        return MSG_PREFIX + msgs + MSG_POSTFIX;
    }
    else {
        if (msgs instanceof Array) {
            if (msgs.length == 0) {
                return "";
            }
            return msgs.join(", ");
        }
        return msgs;
    }
}
const statusCode = (received, expected) => {
    const errorParts = []; // they cause an exception to be thrown in any case (failure and success)
    const failureParts = []; // explanation of failure
    const statusCodeSuccessParts = []; // explanation of success
    checkStatus(received, expected, errorParts, failureParts, statusCodeSuccessParts);
    if (errorParts.length > 0) {
        throw new Error(errorParts.join(","));
    }
    if (failureParts.length === 0) {
        if (statusCodeSuccessParts.length !== 0) {
            return { pass: true, message: () => toMsg(statusCodeSuccessParts) };
        }
        else {
            return { pass: true, message: () => toMsg("No validations errors found.") };
        }
    }
    else {
        return { pass: false, message: () => toMsg(failureParts) };
    }
};
exports.statusCode = statusCode;
const toHaveValidationErrorsExactly = (received, expectedOrNothing) => {
    return checkValidationErrors(false, received, expectedOrNothing);
};
exports.toHaveValidationErrorsExactly = toHaveValidationErrorsExactly;
const toHaveAtLeastValidationErrors = (received, expectedOrNothing) => {
    return checkValidationErrors(true, received, expectedOrNothing);
};
exports.toHaveAtLeastValidationErrors = toHaveAtLeastValidationErrors;
const toHaveNoValidationErrors = (received, expected) => {
    return checkValidationErrors(false, received, expected ? {
        status: expected
    } : undefined);
};
exports.toHaveNoValidationErrors = toHaveNoValidationErrors;
const toHaveAnyValidationErrors = (received, expected) => {
    return checkValidationErrors(true, received, expected ? {
        status: expected
    } : undefined);
};
exports.toHaveAnyValidationErrors = toHaveAnyValidationErrors;
/**
 * @param received
 * @param expectedOrNothing
 * @param atLeast
 *      If set to true AND if any location is defined, the test does not fail if
 *      other validation errors except the given one were omitted.
 *      That is, by default if a specific location.param (or path) is set, no other errors should occur.
 *      This setting is ignored, if no specific locations (or anyLocation) are defined.
 * @returns
 */
const checkValidationErrors = (atLeast, received, expectedOrNothing) => {
    var _a;
    const expected = expectedOrNothing !== null && expectedOrNothing !== void 0 ? expectedOrNothing : {};
    const errorParts = []; // they cause an exception to be thrown in any case (failure and success)
    const failureParts = []; // explanation of failure
    const successParts = []; // explanation of success
    const statusCodeSuccessParts = []; // explanation of success
    const noErrorsInBodyParts = [];
    checkStatus(received, (_a = expectedOrNothing === null || expectedOrNothing === void 0 ? void 0 : expectedOrNothing.status) !== null && _a !== void 0 ? _a : "*", errorParts, failureParts, statusCodeSuccessParts);
    const receivedErrorMap = getReceivedErrorMap();
    if (receivedErrorMap.size > 0 || !atLeast) {
        const foundErrorMap = new Map();
        const specificErrorsWereExpected = checkExpectedErrors(receivedErrorMap, foundErrorMap);
        checkNotExpectedErrors(receivedErrorMap, foundErrorMap, specificErrorsWereExpected);
    }
    if (errorParts.length > 0) {
        throw new Error(errorParts.join(","));
    }
    if (failureParts.length === 0) {
        if (successParts.length !== 0) {
            return { pass: true, message: () => joinWithStatusSuccess(successParts) };
        }
        else if (noErrorsInBodyParts.length !== 0) {
            return { pass: !atLeast, message: () => joinWithStatusSuccess(noErrorsInBodyParts) };
        }
        else {
            return { pass: true, message: () => joinWithStatusSuccess(["No validations errors found."]) };
        }
    }
    else {
        return { pass: false, message: () => joinWithStatusSuccess(failureParts) };
    }
    function joinWithStatusSuccess(parts) {
        if (statusCodeSuccessParts.length > 0) {
            parts.push(...statusCodeSuccessParts);
        }
        return toMsg(parts.join('\n'));
    }
    // ---------------------------------------------------------------------------------------------
    // Internal helper
    function getPathsAtLocation(expectedLocation) {
        const paths = expected[expectedLocation];
        if (!paths) {
            return [];
        }
        if (typeof paths === "string") {
            return [paths];
        }
        return paths;
    }
    function checkExpectedErrors(receivedErrorMap, foundErrorMap) {
        let specificErrorsExpected = false;
        for (const expectedLocation of ALL_LOCATIONS) {
            const expectedPaths = getPathsAtLocation(expectedLocation);
            for (const expectedPath of expectedPaths) {
                specificErrorsExpected = true;
                if (expectedLocation === "anyLocation") {
                    let foundSpecific = false;
                    for (const specificLocation of SPECIFIC_LOCATIONS) {
                        const receivedPaths = receivedErrorMap.get(specificLocation);
                        const index = receivedPaths ? receivedPaths.indexOf(expectedPath) : -1;
                        if (index >= 0) {
                            getMapVal(foundErrorMap, specificLocation).push(expectedPath);
                            successParts.push(`${specificLocation}.${expectedPath} caused a validation error (matching any location).`);
                            foundSpecific = true;
                            break;
                        }
                    }
                    if (!foundSpecific) {
                        failureParts.push(`${expectedPath} did not cause any validation errors at any location.`);
                    }
                }
                else {
                    const receivedPaths = receivedErrorMap.get(expectedLocation);
                    const index = receivedPaths ? receivedPaths.indexOf(expectedPath) : -1;
                    if (index >= 0) {
                        getMapVal(foundErrorMap, expectedLocation).push(expectedPath);
                        successParts.push(`${expectedLocation}.${expectedPath} caused a validation error.`);
                    }
                    else {
                        failureParts.push(`${expectedLocation}.${expectedPath} did not cause any validation errors.`);
                    }
                }
            }
        }
        return specificErrorsExpected;
    }
    function checkNotExpectedErrors(receivedErrorMap, foundErrorMap, specificErrorsExpected) {
        for (const specificLocation of SPECIFIC_LOCATIONS) {
            const receivedPaths = receivedErrorMap.get(specificLocation);
            const foundPaths = foundErrorMap.get(specificLocation);
            if (receivedPaths && foundPaths) {
                receivedErrorMap.set(specificLocation, receivedPaths.filter(receivedParam => foundPaths.indexOf(receivedParam) < 0));
            }
        }
        const unexpectedErrors = [];
        for (const receivedEntry of receivedErrorMap.entries()) {
            if (receivedEntry[1].length > 0) {
                unexpectedErrors.push(...receivedEntry[1].map(param => `${receivedEntry[0]}.${param}`));
            }
        }
        if (unexpectedErrors.length > 0) {
            if (atLeast) {
                successParts.push(`Validation errors at ${unexpectedErrors.join(',')}.`);
            }
            else {
                failureParts.push(`Unexpected validation errors at ${unexpectedErrors.join(',')}.`);
            }
        }
    }
    function getReceivedErrorMap() {
        const map = new Map();
        const body = received === null || received === void 0 ? void 0 : received.body;
        // ReadableStream is only defined in Node > 16!
        // if (received.body instanceof ReadableStream) {
        //     throw Error("This matcher is supposed to run in the context of SuperTest. Response body should have been parsed already.")
        // }
        if (!body) {
            noErrorsInBodyParts.push("No body set in response, cannot match validation errors.");
            return map;
        }
        if (typeof body !== "object") {
            noErrorsInBodyParts.push(`Body found, but it is not an object but ${typeof body}. Did you use restmatcher with supertest?`);
            return map;
        }
        let errors = body;
        for (const path of PATH_TO_VALIDATION_ERRORS_IN_BODY) {
            errors = errors[path];
            if (errors) {
                break;
            }
        }
        if (errors === undefined || errors === null) {
            noErrorsInBodyParts.push(`No validation errors found, property '${PATH_TO_VALIDATION_ERRORS_IN_BODY.join('.')}' not found in body.`);
            return map;
        }
        if (!(errors instanceof Array)) {
            noErrorsInBodyParts.push(`No validation errors found, '${PATH_TO_VALIDATION_ERRORS_IN_BODY.join('.')}' in body is not an array but a ${typeof errors}.`);
            return map;
        }
        for (const error of errors) {
            const location = error.location;
            const name = error.path || error.param; // version 7 vs. vs. 6 of express validator
            getMapVal(map, location).push(name);
        }
        return map;
    }
};
function checkStatus(received, expectedStatusPattern, errorParts, failureParts, statusCodeSuccessParts) {
    const receivedStatus = String(received.status);
    if (receivedStatus.length != 3) {
        if (expectedStatusPattern !== undefined) {
            errorParts.push(`Status ${receivedStatus} is not a valid status code.`);
        }
        else {
            failureParts.push(`Status ${receivedStatus} is not a valid status code.`);
        }
        return;
    }
    if (!expectedStatusPattern || expectedStatusPattern === "*") { // no message if no status code expected or is any
        return;
    }
    const expectedStatusAsArray = normalizeExpectedStatusPattern(expectedStatusPattern);
    let statusOK = false;
    statusArrayLoop: for (const expectedStatus of expectedStatusAsArray) {
        for (let c = 0; c < Math.min(receivedStatus.length, expectedStatus.length); c++) {
            const expectedChar = expectedStatus[c];
            if ('*' === expectedChar) {
                statusOK = true;
                statusCodeSuccessParts.push(`Status code is ${receivedStatus} (matching ${expectedStatus}).`);
                break statusArrayLoop;
            }
            else if (receivedStatus[c] === expectedChar || "xX?".includes(expectedChar)) {
                if (c === expectedStatus.length - 1) {
                    statusOK = true;
                    statusCodeSuccessParts.push(`Status code is ${receivedStatus} (matching ${expectedStatus})`);
                    break statusArrayLoop;
                }
            }
            else {
                break; // inner loop
            }
        }
    }
    if (!statusOK) {
        failureParts.push(`The received status ${receivedStatus} does not match expected status ${expectedStatusAsArray.join(',')}.`);
    }
}
function getMapVal(map, key) {
    let val = map.get(key);
    if (val === undefined) {
        val = [];
        map.set(key, val);
    }
    return val;
}
/**
 * Exported only for testing.
 */
function normalizeExpectedStatusPattern(expectedStatusPattern) {
    if (expectedStatusPattern === undefined) {
        return [];
    }
    if (typeof expectedStatusPattern === "number") {
        return [String(expectedStatusPattern).padEnd(3, "x")];
    }
    if (typeof expectedStatusPattern === "string") {
        return [expectedStatusPattern];
    }
    return expectedStatusPattern.map(pattern => typeof pattern === "number" ? String(pattern).padEnd(3, "x") : pattern);
}
exports.normalizeExpectedStatusPattern = normalizeExpectedStatusPattern;
//# sourceMappingURL=responseMatcher.js.map