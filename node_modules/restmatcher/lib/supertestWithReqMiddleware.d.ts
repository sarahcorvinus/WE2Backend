import express from 'express';
import supertest from "supertest";
/**
 * Works similar as the supertest function, but injects calls to middleware functions for each request
 * (or HTTP method respectively). Actually, this function is a proxy on top of supertest.
 *
 * Example:
 *
 * ```
 * const app = express();
 * app.get("/path", (req, res) => { res.send({value: req.headers.authorization}); });
 *
 * // The middleware function:
 * function auth(req: Test) { return req.set('Authorization', `Bearer THIS_IS_NOT_A_REAL_TOKEN`); }
 *
 * test("WithAuth", async() => {
 *     const testee = supertestWithReqMiddleware(app, auth);
 *     const response = await testee.get("/path");
 *     expect(response.body).toMatchObject({value: "Bearer THIS_IS_NOT_A_REAL_TOKEN"});
 * })
 * ```
 * If you need to add this often, just create a wrapper function:
 * ```
 * function supertestWithAuth(app: express.Express) {
 *      return supertestWithReqMiddleware(app, authenticator);
 * }
 *
 * const testee = supertestWithAuth(app);
 * const response = await testee.get("/path");
 * expect(response.body).toMatchObject({ value: "Bearer THIS_IS_NOT_A_REAL_TOKEN" });
 * ```
 *
 * Note that the type `Test` here needs to be imported via
 * ```
 * import { Test } from 'supertest';
 * ```
 *
 * @param app the express app to test
 * @param middlewareFcts functions that are called for each request (or HTTP method respectively) and can be used to add authentication headers.
 */
export declare function supertestWithReqMiddleware(app: express.Express, ...middlewareFcts: ((req: supertest.Test) => supertest.Test)[]): supertest.SuperTest<supertest.Test>;
//# sourceMappingURL=supertestWithReqMiddleware.d.ts.map