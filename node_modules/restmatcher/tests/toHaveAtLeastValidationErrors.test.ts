import "../src/restmatcher"

const res = {
    status: 400,
    body: {
        "errors": [
            {
                "location": "params",
                "msg": "Invalid value",
                "param": "resID",
                "value": "1234"
            }
        ]
    }
}

const res2 = {
    status: 400,
    body: {
        "errors": [
            {
                "location": "params",
                "msg": "Invalid value",
                "param": "resID",
                "value": "1234"
            },
            {
                "location": "params",
                "msg": "Invalid value",
                "param": "otherID",
                "value": "4567"
            }

        ]
    }
}
const resNoValidationErrors = {
    status: 201,
    body: {}
}


test("no validation error is found does not match that at least errors were expected!", ()=>{
    try {
        expect(resNoValidationErrors).toHaveAtLeastValidationErrors({status: 201});
    } catch (err) {
        // expected
        return
    }
    throw new Error("No error thrown, but should have been");
    
});

test("no validation error is found = not at least!", ()=>{
    expect(resNoValidationErrors).not.toHaveAtLeastValidationErrors({status: 201});
});

test("at least one validation error is found", ()=>{
    expect(res).toHaveAtLeastValidationErrors();
});

test("at least one validation error is found and status code is 400", ()=>{
    expect(res).toHaveAtLeastValidationErrors({status: 400});
});

test("at least one validation error is found and status code is 4*", ()=>{
    expect(res).toHaveAtLeastValidationErrors({status: "4*"});
});

test("at least one validation error is found and status code is a client error", ()=>{
    expect(res).toHaveAtLeastValidationErrors({status: "4xx"});
});

test("at least parameter resID caused a validation error (one occurred)", ()=>{
    expect(res).toHaveAtLeastValidationErrors({params: "resID"});
});

test("at least parameter resID caused a validation error (two occurred)", ()=>{
    expect(res2).toHaveAtLeastValidationErrors({params: "resID"});
});

test("at least one field (body, query, params etc.) named resID caused a validation error", ()=>{
    expect(res).toHaveAtLeastValidationErrors({anyLocation: "resID"});
});

test("at least one field (body, query, params etc.) named resID caused a validation error (two occurred)", ()=>{
    expect(res2).toHaveAtLeastValidationErrors({anyLocation: "resID"});
});

test("negative: succeeds if (at least) no validations errors were omitted", ()=>{
    expect(resNoValidationErrors).not.toHaveAtLeastValidationErrors();
});

test("negative: query resID did not cause a validation error (at least)", ()=>{
    expect(res).not.toHaveAtLeastValidationErrors({query: "resID"});
});

test("at least parameters resID and otherID caused a validation error", ()=>{
    expect(res2).toHaveAtLeastValidationErrors({params: ["resID", "otherID"]});
});

test("at least parameters iAmFine did not cause an error", ()=>{
    expect(res).not.toHaveAtLeastValidationErrors({params: "iAmFine"});
});

test("at least parameters iAmFine did not cause an error", ()=>{
    expect(res).not.toHaveAtLeastValidationErrors({anyLocation: "iAmFine"});
});

test("parameters resID caused an error, but also otherID", ()=>{
    expect(res).toHaveAtLeastValidationErrors({params: "resID"});
});

///////////////////////////////////////////////////////////////////
// negative tests

test("body is not an object is a problem when at least some (=any) validation errors are expected", () => {
    try {
        expect({ status: 500, body: "not an object" }).toHaveAtLeastValidationErrors();
    } catch (err) {
        //import { JestAssertionError } from 'expect';
        // and instanceof check fails: JestAssertionError is not a JestAssertionError
        expect(err).toHaveProperty("matcherResult");
        return;
    }
    throw new Error("Should not be reached, wrong body should throw an error");
});

test("body is not an object is not a problem when NOT at least some (=any) validation errors are expected", () => {
    expect({ status: 500, body: "not an object" }).not.toHaveAtLeastValidationErrors();

});

test("body not found is a problem when at least some (=any) validation errors are expected", () => {
    try {
        expect({ status: 500 }).toHaveAtLeastValidationErrors();
    } catch (err) {
        //import { JestAssertionError } from 'expect';
        // and instanceof check fails: JestAssertionError is not a JestAssertionError
        expect(err).toHaveProperty("matcherResult");
        return;
    }
    throw new Error("Should not be reached, wrong body should throw an error");
});

test("body not found is not a problem when NOT at least some (=any) validation errors are expected", () => {
    expect({ status: 500, body: "not an object" }).not.toHaveAtLeastValidationErrors();

});

test("body.errors is not an array is a problem when at least some (=any) validation errors are expected", () => {
    try {
        expect({ status: 500, body: { errors: "not an array" } }).toHaveAtLeastValidationErrors();
    } catch (err) {
        //import { JestAssertionError } from 'expect';
        // and instanceof check fails: JestAssertionError is not a JestAssertionError
        expect(err).toHaveProperty("matcherResult");
        return;
    }
    throw new Error("Should not be reached, wrong body should throw an error");
});

test("body.errors is not an array not a problem when NOT at least some (=any) validation errors are expected", () => {
    expect({ status: 500, body: { errors: "not an array" } }).not.toHaveAtLeastValidationErrors();

});

// Testing status codes:

test("valid status code and no body should not lead to an assertion with not at least", () => {
    expect({
        status: 200
    }).not.toHaveAtLeastValidationErrors();
});

test("invalid status code should lead to an assertion with at least", () => {
    try {
        expect({
            status: 9999
        }).toHaveAtLeastValidationErrors();
    } catch (err) {
        // we need a real error here, as it fails with "not" and without "not"
        return;
    }
    throw new Error("Should not be reached, invalid status code should throw an error");
});

test("invalid status code should lead to an assertion with not at least", () => {
    try {
        expect({
            status: 9999
        }).not.toHaveAtLeastValidationErrors();
    } catch (err) {
        // we need a real error here, as it fails with "not" and without "not"
        return;
    }
    throw new Error("Should not be reached, invalid status code should throw an error");
});


test("missing status code should lead to an assertion with at least", () => {
    try {
        expect({
        }).toHaveAtLeastValidationErrors();
    } catch (err) {
        // we need a real error here, as it fails with "not" and without "not"
        return;
    }
    throw new Error("Should not be reached, invalid status code should throw an error");
});

test("missing status code should lead to an assertion with not at least", () => {
    try {
        expect({
        }).not.toHaveAtLeastValidationErrors();
    } catch (err) {
        // we need a real error here, as it fails with "not" and without "not"
        return;
    }
    throw new Error("Should not be reached, invalid status code should throw an error");
});