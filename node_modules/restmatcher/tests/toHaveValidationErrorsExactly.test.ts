import "../src/restmatcher"

const res = {
    status: 400,
    body: {
        "errors": [
            {
                "location": "params",
                "msg": "Invalid value",
                "param": "resID",
                "value": "1234"
            }
        ]
    }
}

const res2 = {
    status: 400,
    body: {
        "errors": [
            {
                "location": "params",
                "msg": "Invalid value",
                "path": "resID",
                "value": "1234"
            },
            {
                "location": "params",
                "msg": "Invalid value",
                "path": "otherID",
                "value": "4567"
            }

        ]
    }
}
const resNoValidationErrors = {
    status: 201,
    body: {}
}

const resNoValidationErrorsSomeBody = {
    status: 201,
    body: {
        id: "hello",
        name: "world"
    }
}

test("one (or more) validation error is found", ()=>{
    expect(res).not.toHaveValidationErrorsExactly();
});

test("no validation error is found", ()=>{
    expect(resNoValidationErrors).toHaveValidationErrorsExactly();
});

test("no validation error is found", ()=>{
    expect(resNoValidationErrors).toHaveValidationErrorsExactly({status: 201});
});


test("one validation error is found and status code is 400", ()=>{
    expect(res).not.toHaveValidationErrorsExactly({status: 400});
});

test("one validation error is found and status code is 400 or 500", ()=>{
    expect(res).not.toHaveValidationErrorsExactly({status: [500, 400]});
});

test("one validation error is found and status code is 4xx or 5xx", ()=>{
    expect(res).not.toHaveValidationErrorsExactly({status: ["5xx", "4xx"]});
});

test("one validation error is found and status code is a client error", ()=>{
    expect(res).not.toHaveValidationErrorsExactly({status: "4xx"});
});

test("parameter resID caused a validation error", ()=>{
    expect(res).toHaveValidationErrorsExactly({params: "resID"});
});

test("parameter resID caused a validation error and status 400", ()=>{
    expect(res).toHaveValidationErrorsExactly({status: 400, params: "resID"});
});

test("parameter resID caused a validation error and status 200 (instead of 400)", ()=>{
    expect(res).not.toHaveValidationErrorsExactly({status: 200, params: "resID"});
});

test("parameter resID caused a validation error and status 4xx", ()=>{
    expect(res).toHaveValidationErrorsExactly({status: "4xx", params: "resID"});
});

test("parameter resID caused a validation error and status 4*", ()=>{
    expect(res).toHaveValidationErrorsExactly({status: "4*", params: "resID"});
});

test("one field (body, query, params etc.) named resID caused a validation error", ()=>{
    expect(res).toHaveValidationErrorsExactly({anyLocation: "resID"});
});

test("succeeds if no validations errors were omitted", ()=>{
    expect(resNoValidationErrors).toHaveValidationErrorsExactly();
});

test("negative: query resID did not cause a validation error", ()=>{
    expect(res).not.toHaveValidationErrorsExactly({query: "resID"});
});

test("parameters resID and otherID caused a validation error", ()=>{
    expect(res2).toHaveValidationErrorsExactly({params: ["resID", "otherID"]});
});

test("parameters resID caused an error, but also otherID", ()=>{
    expect(res2).not.toHaveValidationErrorsExactly({params: "resID"});
});

test("parameters iAmFine did not cause an error", ()=>{
    expect(res).not.toHaveValidationErrorsExactly({params: "iAmFine"});
});

///////////////////////////////////////////////////////////////////
// negative tests

test("body not found is a problem when exactly no validation errors are not expected, i.e. we expect errors", () => {
    try {
        expect({ status: 500 }).not.toHaveValidationErrorsExactly();
    } catch (err) {
        //import { JestAssertionError } from 'expect';
        // and instanceof check fails: JestAssertionError is not a JestAssertionError
        expect(String(err)).toBe("Error: No body set in response, cannot match validation errors.")
        return;
    }
    throw new Error("Should not be reached, wrong body should throw an error");
});

test("body not found is not a problem when exactly no validation errors are expected", () => {
    expect({ status: 500 }).toHaveValidationErrorsExactly();
});

test("body is not an object is a problem when exactly no validation errors are not expected, i.e. we expect errors", () => {
    try {
        expect({ status: 500, body: "not an object" }).not.toHaveValidationErrorsExactly();
    } catch (err) {
        //import { JestAssertionError } from 'expect';
        // and instanceof check fails: JestAssertionError is not a JestAssertionError
        expect(String(err)).toBe("Error: Body found, but it is not an object but string. Did you use restmatcher with supertest?")
        return;
    }
    throw new Error("Should not be reached, wrong body should throw an error");


});

test("body.errors is not an array is a not a problem if zero validation errors are expected", () => {
    expect({ status: 500, body: { errors: "not an array" } }).toHaveValidationErrorsExactly();
});

test("body.errors is not an array is a problem when NOT exactly no validation errors are not expected, i.e. we expect errors", () => {
    try {
        expect({ status: 500, body: { errors: "not an array" } }).not.toHaveValidationErrorsExactly();
    } catch (err) {
        //import { JestAssertionError } from 'expect';
        // and instanceof check fails: JestAssertionError is not a JestAssertionError
        expect(String(err)).toBe("Error: No validation errors found, 'errors' in body is not an array but a string.")
        return;
    }
    throw new Error("Should not be reached, wrong body should throw an error");
});

test("body.errors is not an array is a problem when validation errors are expected, i.e. we expect errors", () => {
    try {
        expect({ status: 500, body: { errors: "not an array" } }).toHaveValidationErrorsExactly({params: "resID"});
    } catch (err) {
        //import { JestAssertionError } from 'expect';
        // and instanceof check fails: JestAssertionError is not a JestAssertionError
        expect(String(err)).toBe('Error: params.resID did not cause any validation errors.')
        return;
    }
    throw new Error("Should not be reached, wrong body should throw an error");
});



// Testing status codes:

test("valid status code and no body should not lead to an assertion with exactly", () => {
    expect({
        status: 200
    }).toHaveValidationErrorsExactly();
});


test("invalid status code should lead to an assertion with exactly", () => {
    try {
        expect({
            status: 9999
        }).toHaveValidationErrorsExactly();
    } catch (err) {
        // we need a real error here, as it fails with "not" and without "not"
        expect(String(err)).toBe('Error: Status 9999 is not a valid status code.');
        return;
    }
    throw new Error("Should not be reached, invalid status code should throw an error");
});

test("invalid status code should lead to an assertion with not exactly", () => {
    try {
        expect({
            status: 9999
        }).not.toHaveValidationErrorsExactly();
    } catch (err) {
        // we need a real error here, as it fails with "not" and without "not"
        expect(String(err)).toBe
        return;
    }
    throw new Error("Should not be reached, invalid status code should throw an error");
});



test("missing status code should lead to an assertion with exactly", () => {
    try {
        expect({
        }).toHaveValidationErrorsExactly();
    } catch (err) {
        expect(String(err)).toBe('Error: Status undefined is not a valid status code.');
        // we need a real error here, as it fails with "not" and without "not"
        return;
    }
    throw new Error("Should not be reached, invalid status code should throw an error");
});

test("missing status code should lead to an assertion with not exactly", () => {
    try {
        expect({
        }).not.toHaveValidationErrorsExactly();
    } catch (err) {
        // we need a real error here, as it fails with "not" and without "not"
        expect(String(err)).toBe('Error: Status undefined is not a valid status code.');
        return;
    }
    throw new Error("Should not be reached, invalid status code should throw an error");
});
